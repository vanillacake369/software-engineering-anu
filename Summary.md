# Summary

# 1장 소프트웨어공학 소개

## 프로그램 VS 소프트웨어

- 프로그램
: 프로그래밍한 원시코드
- 소프트웨어
:  코드, 각 단계에서 만들어지는 산출물, 사용자 메뉴얼 등도 포함한다.

## 소프트웨어의 종류

- 관리 소프트웨어
: 자료를 받아들여 가공한 후 정보를 제공하는 소프트웨어
- 제어 소프트웨어
: 각종 센서를 이용하거나 기기들의 동작을 제어하는 소프트웨어
- 임베디드 소프트웨어
: 장비나 기기 내장된 형태의 소프트웨어

---

## 실패곡선

### 하드웨어 실패곡선

![Untitled](Summary%20a234e67e4fe941f2a6cc57056f7bfb82/Untitled.png)

### 이상적인 SW 실패곡선

![Untitled](Summary%20a234e67e4fe941f2a6cc57056f7bfb82/Untitled%201.png)

### 실제 SW 실패곡선

![Untitled](Summary%20a234e67e4fe941f2a6cc57056f7bfb82/Untitled%202.png)

****** 실패율 급격히 증가함과 변경발생이 반복되는 구조를 유의깊게 보아라 ******

![Untitled](Summary%20a234e67e4fe941f2a6cc57056f7bfb82/Untitled%203.png)

---

## SW 당면문제

- SW 개발의 느린 발전 속도
- 새로운 SW에 대한 사용자 요구 증가
    - HW : 부품 조립 형태
    - SW : 처음부터 만들어가는 개발형태
    
    → 이를 해결하기 위해 CBD개발방법론 탄생
    
- 관리기술의 부분적 활용
: SW개발에도 관리가 필요하다
    - Cost
    - Quality
    - Schedule
    
    → PMBOK을 활용한 적극적인 프로젝트 관리가 필요하다.
    

## 대규모 SW 개발의 어려움

- 개발과정이 복잡
- 참여인력이 많다
- 개발기간이 길다

---

## 소프트웨어 공학 정의와 목표

- 정의

> 품질 좋은 SW를 경제적으로 개발하기 위해 계획 세우고, 개발하고, 유지/관리하는 전 과정에서 공학,과학,수학적 원리 방법을 적용하여 필요한 이론과 기술 및 도구들에 관해 연구하는 학문
> 
- 목표
    - 개발 과정 생산성 향상
    - 고품질 SW 생산하여 사용자 만족을 높임

---

## SDLC

### 계획

- 개발 비용 산정
    - COCOMO 모델
    - FP(Functional Point) 모델
- 일정 계획
- 위험관리

### 요구분석

1. 기존 시스템 문제점 파악
2. 새로운 요구사항 도출
3. 다이아그램 작성
- 개발방법론 : 표현도구
    - 구조적 방법론 : DFD,DD,Mini Spec
    - 정보공학 방법론 : E-R Diagram (Entity-Relation)
    - 객체지향 방법론 : Usecase Diagram
- 최종 산출물 : 요구 분석 명세서

### 설계

: 시스템의 전체적인 뼈대를 세우는 작업

- 아키텍처 스타일
- GoF의 디자인패턴
- 모듈 평가 : 응집도,결합도

### 구현

구현 규칙인 표준코딩 규칙 정의

### 테스트

1. 테스트 계획
2. 테스트 케이스 설계
3. 테스트 실행 및 측정
4. 결과 분석 및 평가
5. 오류 추적 및 수정

### 유지보수 ~~(응 나오면 틀려)~~

- 수정 유지보수
- 적응 유지보수
- 기능 보강 유지보수
- 예방 유지보수

### 품질관리

- CMMI
- SPICE

![Untitled](SPICE%20CMMI%20f92f4d6741a447588e879def24807831/Untitled.png)

| L5 | 지속적인 프로세스 개선활동 |
| --- | --- |
| L4 | 프로세스,능력 등을 정량화하여 이해,예측,관리 |
| L3 | 사내 프로세스 표준화 |
| L2 | 계획,절차에 의해 산출물 생성 |
| L1 | 계획 없이 산출물 존재하며 수행된다 |
| L0 | 미구현,목적 미달성 |

### 프로젝트 관리

- 형상관리
- PMBOK(Project Management Body of Knowledge)의 9가지 관점
    - 프로젝트 통합 관리
    - 프로젝트 범위 관리
    - 프로젝트 일정 관리
    - 프로젝트 비용 관리
    - 프로젝트 품질 관리
    - 프로젝트 인적자원 관리
    - 프로젝트 의사소통 관리
    - 프로젝트 위험 관리
    - 프로젝트 조달 관리

---

# 2장 소프트웨어 개발 프로세스

## 소프트웨어 개발에서의 프로세스

: 순서의 집합 + 제약조건을 포함하는 일련의 활동

### 좁은 의미의 소프트웨어 개발에서의 프로세스

- SW 개발 시, 필요한 절차,과정,구조
- 요구사항을 구현하기 위한 일련의 활동
- [절차와 과정은 다른 의미이다.](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=jvioonpe&logNo=220248237114#:~:text=%E2%80%8B%EC%A0%88%EC%B0%A8(Procedure)%EC%99%80%20%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4,%EC%9C%A0%EC%82%AC%ED%95%98%EA%B2%8C%20%ED%92%80%EC%9D%B4%EB%90%98%EC%96%B4%20%EC%9E%88%EB%8B%A4.)
    
    절차는 일을 치르는데 거쳐야 하는 순서나 방법,
    
    프로세스는 일이 수행되는 경로나 공정
    
    즉, 절차는 "작업에 대한 일련의 활동 순서", 프로세스는 "활동 그룹 간의 상호작용
    "
    

### 넓은 의미의 소프트웨어 개발에서의 프로세스

- 절차,구조,방법,도구,참여자까지 모두 포함
- SW 개발 목적을 이루기 위해 필요한 통합적 수단

---

## 프로세스의 목적

![Untitled](Summary%20a234e67e4fe941f2a6cc57056f7bfb82/Untitled%204.png)

> **노하우를 전달하는 것에 주목해라. 노하우를 전달하지 않는다면 SW개발 프로세스의 의의가 사라진다**
*- 이은서 Prof*
> 

## 소프트웨어 프로세스 모델 정의/목적 3가지/역할 7가지

### 정의

SW를 어떻게 개발할 것인가 전체적인 흐름을 체계화한 개념

### 목적

- SW개발 전 과정을 하나의 프로세스로 정의
- 주어진 예산,자원으로 개발하고 관리하는 방법을 구체적으로 저으이
- 고품질 SW제품생산을 목적으로 함

### 역할

- 프로젝트 기본골격 세움
- 일정계획 수립
- 자원 산정,분배
- 의사소통 기준 정립
- 용어의 표준화 정의
- 개발진행상황 파악
- 각 단계별 산출물 활용하여 검토가능케 함

---

## 주먹구구식 모델

![Untitled](Summary%20a234e67e4fe941f2a6cc57056f7bfb82/Untitled%205.png)

### 장점

- 품질이 개발실력과 비례하다
- 간단한 프로젝트에 적합

### 단점

- 결함 분석 불가능
- 요구사항 추적 불가능
- 산출물 없어 관리 및 유지보수 불가능
- 진척상황 파악 불가능
- 수정이 매우 어렵다.

## Waterfall

![Untitled](Summary%20a234e67e4fe941f2a6cc57056f7bfb82/Untitled%206.png)

### 장점

- 관리 용이
- 체계적 문서화
- 요구사항 변화 적은 프로젝트에 적합

### 단점

- 앞 단계가 완료되어야 수행가능
- 완벽한 수준으로 각 단계 결과물이 작성되어야 오류 넘기지 않는다
- 사용자가 중간에 가시적인 결과를 볼 수 없다.

## V 모델

![Untitled](Summary%20a234e67e4fe941f2a6cc57056f7bfb82/Untitled%207.png)

- 단위 테스트
: 모듈 동작 여부 검증
- 통합 테스트
: 인터페이스 오류 및 모듈 상호 간 결합도 검증
- 시스템 테스트
: 실제 HW에 얹어 시스템 전체 동작 여부 검증
- 인수 테스트
: 사용자가 요구분석 명세서의 사항들을 충족하는지 테스트

## 프로토타입 모델

![Untitled](Summary%20a234e67e4fe941f2a6cc57056f7bfb82/Untitled%208.png)

![Untitled](Summary%20a234e67e4fe941f2a6cc57056f7bfb82/Untitled%209.png)

### 실험적 프로토타입 모델

![Untitled](Summary%20a234e67e4fe941f2a6cc57056f7bfb82/Untitled%2010.png)

### 진화적 프로토타입 모델

![Untitled](Summary%20a234e67e4fe941f2a6cc57056f7bfb82/Untitled%2011.png)

### 프로토타입 모델 개발절차

1. 요구사항 정의/분석
2. 프로토타입 설계
: UI/UX 중심 설계
3. 프로토타입 개발
    - 입력 화면을 통한 사용자 요구항목 확인
    - 출력 결과를 통해 사용자 원하는 것인지 확인
4. 사용자에 의한 평가

![Untitled](Summary%20a234e67e4fe941f2a6cc57056f7bfb82/Untitled%2012.png)

1. 구현
: 최종 프로토타입 개발

### 장점

- 프로토타입이 의사소통 도구로 활용됨
- 반복된 요구사항 정의를 통해 요구분석 명세서 작성
- 초기 프로토타입 사용을 통한 새로운 요구사항 발견
- 프로토타입 사용을 통한 완성품의 예측 가능

### 단점

- 반복적 개발을 통한 투입 인력 및 비용 산정의 어려움
- 프로토타이핑 과정에 대한 통제 및 관리의 어려움
- 중간 산출물 생성의 어려움
- 불명확한 개발 범위로 인한 개발 종료 및 목표의 불확실성

# 요구분석의 어려움 7가지

---

- 문제영역에 대한 이해력 부족
- 의사 소통의 문제
    - 견본이 없어 요구 사항 설명이 어려움
    - 사용자가 요구 사항에 대한 설명 방법을 잘 모름
    - 사용자 의사 전달 능력이 요구 사항 전달 내용에 영향을 미침
    - 일관성이 없거나 불안전한 요구 분석 명세서
- 계속 변하는 요구 사항
    - 초기의 요구 사항은 단순
    - 개발될 SW에 대해 이해의 폭이 넓어짐에 따라 새로운 요구 사항 발생 및 증가
    - 관련 지식의 증가로 인한 요구 사항 변경 발생
- 변경 요구에 대한 대처 방안
    - 변경 사항에 대한 날짜별, 기간별 기록
    - 변경이 미치는 영향에 대해 사전 분석 필요
- 애매모호한 표현
    - 해석을 달리할 수 있는 애매한 표현의 요구
    - 사용자의 일관성 없는 요구
    - 부서간의 상충된 요구
    - 경영진과 실무자간의 상반된 요구
- 분석가의 역할
    - 수집된 요구들을 반영하기 전에 이해 당사자들 간의 주장을 조율할 수 있어야 함
- 사용자와 개발자의 마찰
    - 최적의 분석명세서에 대한 사용자의 다른 해석으로 인한 마찰

# 분석가 능력 4가지

---

- 분석가의 주 업무
    - 사용자의 요구를 정확하고 완전하게 획득하는 것
    - 방법: 다양한 참여자를 만족시킬 수 있는 공통의 목표를 추출
- 의사 소통과 협상 능력
    - 상반된 의견        조율 능력
    - 무리한 요구        우선 순위 결정 및 실현 가능한 요구 판별 능력
    - 추상적 요구        논리적 분할을 통한 해결 방안 제시
- 개발 업무 영역에 대한 지식
    - 업무 담당자와 원할 한 대화 가능
    - 주도적으로 추진 가능
- 개발 관련 기술에 대한 지식
    - 사용자의 요구가 기술적으로 구현 가능한지 판단 능력 필요
- 이해 관계자들의 상반된 요구에 대한 중재 능력
    - 경영자: 투자 대비 효과에 관심
    고객(발주자):  개발비가 적고, 개발 기간 엄수할 수 있는 업체에 관심
    사용자: 업무의 효율적 처리와 편리성 등에 관심
    
    => 경영자, 고객, 사용자의 상반된 요구에 대해 중재 및 조율 능력 필요
    

# 품질 종류 5가지 & 신뢰도 측정

---

- 신뢰성(reliability)
    - 신뢰: 소프트웨어를 믿고 사용할 수 있는 것
    사용자가 주어진 시간과 환경에서 고장 없이 사용할 수 있어야 한다는 것
    - 신뢰도: 장애 없이 동작하는 시간의 비율
    (예) 신뢰도 98%(0.98): 100번 수행했을 때 오류 없이 동작하는 회수가 98번
    - 신뢰도 측정
    고장 간 평균 시간(MTBF)과 이용 가능성(가용성)을 척도로 사용
        - MTBF = MTTF + MTTR
        • MTBF(고장 간 평균 시간, Mean Time Between Failure): 고장에서 다음 고장까지의 평균 시간
        • MTTF(평균 실패 시간, Mean Time To Failure): 수리한 후 다음 고장까지의 평균 시간
        • MTTR(평균 수리 시간, Mean Time To Repair): 고장 발생 시점에서 수리 시까지의 평균 시간
        - 이용 가능성(availability) = MTTF/(MTTF+MTTR)X100%
            - 이용 가능성(가용성): 주어진 시점에서 프로그램이 요구에 따라 작동되고 있을 가능성
- 성능(performance)
사용자가 시스템에 어떤 요구를 했을 때 해당 기능을 정상적으로 수행하는 것은 물론, 사용자가 원하는 조건(응답 시간, 데이터의 처리량 등)을 만족시키는 것
(예 1) 대학 종합정보시스템은 수강 신청 시 동시 접속자 수 10,000명은 가능해야 한다.
(예 2) 도서 관리 시스템에서 사용자가 책을 검색한 결과를 2초 이내로 보여주어야 한다.
- 보안성(security)
인증을 받지 않은 사람이 시스템에 접근하는 것을 처음부터 막아 시스템과 데이터를 보호
- 안전성(safety)
작동하는 모든 시스템이 소프트웨어 오류로 인해 인명 피해가 발생하지 않도록
(예 1) 공장의 생산 라인에 사람 손이나 물체가 인식되면 절단 작업이 중단되어야 한다.
(예 2) 전동차 출발 시 문에 가방 같은 물체가 끼면 출발을 멈춰야 한다.
- 사용성(usability)
소프트웨어를 사용할 때 혼란스러워하거나 사용하는 순간에 고민하지 않게 하는 편의성
의미가 같은 단어 두 개를 혼용하여 사용자를 혼란스럽게 하는 경우
주민번호를 입력할 때 ‘-’를 넣어야 할지 말아야 할지 명확하게 제시해주지 못하는 경우

# 이해당사자 관점의 요구분석명세서

---

- 사용자 입장
사용자와 의사 소통하는 도구로 사용되면서 동시에 계약서로도 사용
개발이 완료 시 이 문서의 내용이 판단 기준으로 사용
개발된 소프트웨어의 수용 여부를 결정하는 데 사용
- 개발자 입장
요구 분석 명세서를 읽고 어떤 시스템이 개발될 것인지 이해하는데 사용
요구 분석 명세서에 기술된 기능적/비기능적 요구 사항을 기반으로 분석, 설계, 코딩
개발이 완료 후 요구 분석 명세서 대로 구현되었는지 점검 항목으로 사용
사용자 지침서 초안 작성용으로 사용
- 테스터 입장
테스트 케이스 생성 및 오류에 대한 판단과 동작에 대한 기준으로 사용

# 요구분석명세서 작성 시 주의사항

---

- 사용자가 읽기 쉽고, 이해할 수 있도록 작성
- 개발자가 설계와 코딩에 효과적으로 사용할 수 있도록 작성
- 비기능적 요구를 명확히 작성
- 테스트 기준 용도로 사용할 수 있도록 정량적으로 작성
- 품질에 대한 우선순위를 명시
    - 상충 관계(trade-off) 시 품질 우선 순위를 정할 것

# 잘 만든 요구분석명세서 특징

---

- 완전성(completeness)
‘완전하다’는 말은 빠진 부분 없이 모두 있다는 의미이다.
기능적 요구사항뿐 아니라 성능, 제약 사항 등 누락되지 않고 모두 서술되어야 한다.
BUT!
가끔씩 빠트리는 요구 사항 존재
일반적이고 정상적인 요구 사항이 아닌 예외처리처럼 아주 드물게 발생하는 요구 사항
- 명확성(unambiguity)
요구 분석 명세서: 계약서와 같은 효력 발생        문제 발생 시 근거 자료로 활용
∴ 애매모호하지 않은 명확한 표현으로 작성        관점에 따라 다른 해석 불가하도록 작성
- 일관성(consistency), 무모순성
일관성 없는  명세서: 서로 상반된 요구, 불일치한 요구, 중복된 요구가 존재
- 변경 용이성(modifiability)
변경하기 쉽게 요구 분석 명세서를 작성하는 것
방법: 요구 사항이 서로 의존적이지 않고 독립적으로 서술되어야 함
- 검증 가능성(verifiability)
방법: 시스템이 요구 사항을 만족하는지에 대해 체계적으로 검사할 수 있게 작성
잘못된 예: 많은 학생이 동시에 수강 신청을 해도 문제가 없어야 한다.
잘된 예: 10,000명의 학생이 동시에 수강 신청을 해도 문제가 없어야 한다.
- 추적 가능성(traceability)
추적이 가능하도록 요구 분석 명세서를 작성하는 것

# 요구명세기법

---

- 비정형 명세 기법
자연어, 다이어그램 사용
(장점 1) 특별한 기술이 필요 없어 작성하기 쉽다.
(장점 2) 쉬운 이해       용이한 의사 전달      사용자의 적극적 참여 유도
(단점 1) 자연어 사용       애매모호한 표현        다른 해석 가능       일관성 떨어짐
- 정형 명세 기법
Z 정형 명세 언어(수학적 원리와 기법 사용)
(장점 1) 정확하고 간결한 표현       증명 기술을 이용한 일관성/완전성 검증
(장점 2) 정형화된 형태의 명세       테스트케이스 생성 용이
(단점 1) 수학적 표기법 공부        표기법을 이용한 정확한 표현

# 소프트웨어 설계문서 목록

---

1. 제목/목차
2. 서론
3. 참조문서
4. UI설계
5. 설계구조
6. 모듈설계
7. DB/전역변수
8. 가정
9. 요구사항상호참조테이블(Requirements Cross Reference Table)
10. 시험조항
11. 요약
12. 감사의 글
13. 부록

# 소프트웨어 설계 기술적측면/관리적측면 도표와 설명

---

![Untitled](Summary%20a234e67e4fe941f2a6cc57056f7bfb82/Untitled%2013.png)

설계는 기술적인 관점에서 크게 4가지 활동, 즉 데이터 설계, 구조 설계, 프로시져 설계, 사용자 인터페이스 설계로 나눌 수 있다.

- 데이터 설계(data design) : 요구사항 분석 단계의 정보 모델링에서 밝혀진 정보를 이용하여 자료 구조와 데이터베이스를 설계한다.
- 구조 설계(architectural design) : 기능 모델링과 동적 모델링에 나타난 결과를 이용하여 프로그램 구조상에 있는 각 구성 요소(모듈)들 사이의 관계를 기술한다.
- 프로시져 설계(procedural design) : 각 모듈의 내부가 구체적으로 밝혀지며 어떤 알고리즘을 사용할지 결정한다.
- 사용자 인터페이스 설계(user interface design) : 사용자가 시스템의 기능에 접근할 수 있도록 하는 사용자 인터페이스를 설계한다.

# 설계에서 은닉되어야할 정보들 4가지

---

설계에서 은닉되어야 할 기본 정보

1. 상세한 데이터 구조
2.  하드웨어 디바이스를 제어하는 부분
3. 특정한 환경에 의존하는 부분(예를 들면 특수한 운영체제에 의존하는 부분 또는 특정한 DBMS에 

의존하는 부분 등)

1. 물리적 코드(예를 들면 IP 주소, 문자코드 등)

# 독립성 & 응집도 & 결합도 정의

---

- 소프트웨어 구성 요소의 기능적 독립성은 모듈화 과정과 정보 은닉 개념에서 나타나는 부산물이다.
각 모듈이 하나의 기능만을 수행하며 다른 모듈들과의 상호 교류와 결합을 최소화시킬 때 모듈의 기능적 독립성은 극대화될 수 있다.
모듈간의 관계가 많고 복잡하면 소프트웨어 설계가 복잡하여 설계에 투여되는 노력이 많게 들게되며 설계 비용도 높아 지게 된다.
모듈간의 관계가 많고 복잡하면 소프트웨어의 이해가 어렵게 되고 작은 설계 변경이 요구되어도 많은 모듈에 영향을 주어 유지보수를 어렵게 할 수 있다.
모듈간의 관계가 최소화되고 단순한 경우 모듈의 독립성이 높다고 일컫는다.
설계 목표는 이해하기 쉽고 수정이 쉬운 소프트웨어를 만드는 것이며 높은 독립성을 갖고 있는 모듈들을 설계하는 것은 그 기본이라 할 수 있다.
- 응집도(cohesion)는 모듈 내부가 얼마나 단단히 뭉쳐져 있는가를 나타내는 성숙도의 측정치이다.
또한 응집도는 모듈이 하나의 임무를 수행하는 정도를 나타내는 것으로 모듈의 독립성을 측정하는 또 다른 척도이다.
- 결합도(coupling)는 모듈 사이의 상호 연관성의 복잡도를 일컫는다.
모듈들 사이의 상호 교류가 많고 서로의 의존이 많을수록 모듈들 사이의 결합도는 높아지게 된다.

# 결합도 & 응집도 스펙트럼 도식화와 설명

---

## 응집도

---

### (우)리 (논)던 (시)(절) 그(대) (순)수했고 (함)께했던

우연적/논리적/시간적/대화적/순차적/함수적

## 결합도

---

### (데)이트 섹(스) (제)(외)하면 (공)놀이가 (내) 취미임

직접적결함x/데이터/스템프/제어/외부/공통/내용

![Untitled](Summary%20a234e67e4fe941f2a6cc57056f7bfb82/Untitled%2014.png)

우연적 응집도(coincidental cohesion)

- 모듈내의 구성 요소들이 뚜렷한 연결성을 가지고 있지 않다.
- 뚜렷한 의미나 기능은 없지만 여러 모듈에 유사한 명령문들이 중복되어 있는 경우에 단지 중복되는 부분을 줄이려고 이를 묶어 모듈을 설계하였다면 이런 모듈은 우연적 응집도를 갖게 된다.

논리적 응집도(logical cohesion)

- 설계시 논리적으로 연관된 임무나 비슷한 기능(예: 입출력, 오류 처리 기능나 비슷한 기능)을 묶어 한 모듈을 구성

시간적 응집도(temporal cohesion)

- 모듈내 구성 요소들이 서로 다른 기능을 같은 시간대에 함께 실행하는 경우
- 초기화 모듈은 흔히 볼 수 있는 시간적 응집도 모듈

절차적 응집도(procedural cohesion)

- 모듈내 구성 요소들이 연관성이 있고, 특정 순서에 의해 수행되어야 하는 경우에 절차적 응집도를 가진다.
- 프로세스의 절차적인 요구 조건에 따라 모듈을 설계할 경우 모듈이 단지 절차의 한 부분이라는 이유로 설계되었다면 응집도가 낮은 절차적 응집도만을 가진 모듈로 될 수 있다.

대화적 응집도(communicational cohesion)

- 모듈이 여러 가지 기능을 수행하며 모듈 내 구성 요소들이 같은 입력 자료를 이용하거나 동일 출력 데이터를 만들어 내는 경우
- 모듈화에서 프로세스 절차와 데이터를 동시에 고려하여 모듈화된 것으로서 해결하려는 문제와 많은 연관성을 갖고 있음

순차적 응집도(sequential cohesion)

- 모듈 내 하나의 활동으로부터 나온 출력 데이터를 그다음 활동의 입력 데이터로 사용할 경우의 응집도

함수적 응집도(functional cohesion)

- 한 기능을 수행하기 위해 각 구성 요소들이 필요한 경우
- 이런 모듈 내부 요소들은 가장 밀접히 연관되어 있고, 또한 높은 응집도를 갖고 있다. - 이런 모듈은 오직 하나의 기능을 수행함으로서 이해하기가 쉽고 수정하기도 쉽다.

# 결합도

---

결합도에 영향을 미치는 4가지 요소

모듈들 사이의 연결 유형

- 모듈들 사이의 연결은 한 모듈안에 있는 요소가 다른 모듈에 의해 참조될 때 발생한다.

인터페이스의 복잡도

- 각 인터페이스는 모듈들의 연결을 위해 꼭 필요한 정보만을 표시하여 복잡도가 최소화될 수 있도록 만들어져야 한다.

정보 흐름의 유형

- 모듈들 사이에 교류되는 정보의 유형에는 크게 데이터와 제어 신호가 있다.

바인딩 시간

- 모듈 사이의 연결을 묶는 때를 바인딩 시간(binding time)이라 하며, 컴파일(compiling)할 때, 로딩(loading)할 때, 실행(execution)할 때 등이 있다. 실행 시간에 바인딩되면 로딩 시간에 바인딩된 것보다 결합도가 약하며, 로딩 시간에 바인딩되면 컴파일 시간에 바인딩된 것 보다 결합도가 약하다.

![Untitled](%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%20%E1%84%91%E1%85%AE%E1%86%B7%E1%84%8C%E1%85%B5%E1%86%AF%E1%84%8B%E1%85%AD%E1%84%89%E1%85%A9%20ded43392b9c74320953d95295a021e0a/Untitled%201.png)

직접적 결합이 없음(no direct coupling)

- 서로 독립적이고 상호 교류가 없는 경우이거나, 두 모듈이 다른 모듈에 속해있어 직접적으로 연결되어 있지 않을 때

데이터 결합도(data coupling)

- 한 모듈이 간단한 데이터들을 매개 변수를 통해 다른 모듈과 주고받는 경우

스탬프 결합도(stamp coupling)

- 스탬프 결합도는 레코드 또는 배열과 같은 복잡한 데이터 구조를 모듈 인터페이스를 통해 주고받는 경우
- 스탬프 결합도에서 호출 모듈과 피호출 모듈간에 데이터 교환에서 사용되는 자료구조를 공통으로 쓰고 있기에 이런 자료구조에 대한 정보를 알아야 한다.

제어 결합도(control coupling)

- 모듈 사이에 제어 신호를 주고받아 다른 모듈의 행위를 변경할 수 있는 경우이다.
이 때 제어 신호(flag)가 하부 모듈에 전달되어 그 행위를 결정하게 된다.
데이터를 교류하는 것보다 제어 신호를 교류하는 경우 모듈들 사이의 결합도가 높다.

외부 결합도(external coupling)

- 입출력의 경우 모듈이 특수한 하드웨어에 결합되어 있거나, 통신 프로토콜, 운영체제(O/S), 컴파일러 등과 같은 소프트웨어 이외의 다른 시스템 구성 요소와 결합되어 있는 경우

공통 결합도(common coupling)

- 모듈들이 간단한 타입을 갖고 있는 전역 변수(global variable)를 사용하는 경우 이 모듈들 사이에 공통 결합도를 갖고 있다
공통 결합은 다음과 같은 결점이 있다. 첫째, 변수 값의 초기화 시기를 각 모듈이 미리 알고 있어야 한다. 둘째, 전역 변수는 모듈 사이에 정보를 교환하는데 사용된다.

내용 결합도(content coupling)

- 한 모듈이 다른 모듈 내부에 있는 데이터나 제어 신호를 사용하는 경우이거나, 다른 모듈의 중간에 뛰어들어가는(branching) 경우
모듈들이 서로 상대방의 내부 정보를 직접 이용한다는 것은 모듈화가 잘 되어있지 않다는 것이며 소프트웨어의 설계에서 극소수 상황을 제외하고는 이런 연결을 피하여야 한다.

# 결합도에 영향을 미치는 4요소

---

- 모듈들 사이의 연결 유형
모듈들 사이의 연결은 한 모듈안에 있는 요소가 다른 모듈에 의해 참조될 때 발생한다.
- 인터페이스의 복잡도
각 인터페이스는 모듈들의 연결을 위해 꼭 필요한 정보만을 표시하여 복잡도가 최소화될 수 있도록 만들어져야 한다.
- 정보 흐름의 유형
모듈들 사이에 교류되는 정보의 유형에는 크게 데이터와 제어 신호가 있다.
- 바인딩 시간
모듈 사이의 연결을 묶는 때를 바인딩 시간(binding time)이라 하며, 컴파일(compiling)할 때, 로딩(loading)할 때, 실행(execution)할 때 등이 있다. 실행 시간에 바인딩되면 로딩 시간에 바인딩된 것보다 결합도가 약하며, 로딩 시간에 바인딩되면 컴파일 시간에 바인딩된 것 보다 결합도가 약하다.